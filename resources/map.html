<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            width: 100%;
            height: 100%;
        }

        .node-marker {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .node-pin {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            font-family: Arial, sans-serif;
        }

        .node-pointer {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #333;
            margin-top: -2px;
        }

        .node-tooltip {
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: Arial, sans-serif;
            white-space: pre-line;
        }

        @keyframes node-blink {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7);
            }

            50% {
                transform: scale(1.2);
                box-shadow: 0 0 20px 10px rgba(255, 255, 0, 0.9);
            }
        }

        @keyframes node-ring {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .node-blinking .node-pin {
            animation: node-blink 0.8s ease-in-out infinite;
            z-index: 1000 !important;
        }

        .node-blinking::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            margin-top: -12px;
            margin-left: -12px;
            border: 3px solid #ffff00;
            border-radius: 50%;
            animation: node-ring 1.2s ease-out infinite;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>
        // Initialize map
        var map = L.map('map', {
            zoomControl: true
        }).setView([37.7749, -122.4194], 10);

        // Add tile layer (default OpenStreetMap)
        var currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
            maxZoom: 19
        }).addTo(map);

        // Store markers
        var markers = {};

        // Store packet flow lines
        var packetFlows = [];
        var maxFlowLines = 100; // Keep only last 100 lines

        // Store traceroute line
        var tracerouteLine = null;
        var tracerouteMarkers = [];

        // Color palette for nodes
        var colors = ["#4A90D9", "#D94A4A", "#4AD94A", "#D9D94A", "#D94AD9", "#4AD9D9"];

        function getNodeColor(node) {
            if (node.batteryLevel > 0) {
                if (node.batteryLevel < 20) return "#FF4444";
                if (node.batteryLevel < 50) return "#FFAA00";
                return "#44AA44";
            }
            return colors[node.nodeNum % colors.length];
        }

        function buildTooltip(node) {
            var lines = [];
            if (node.longName) lines.push(node.longName);
            if (node.nodeId) lines.push(node.nodeId);
            if (node.altitude) lines.push("Alt: " + node.altitude + "m");
            if (node.batteryLevel > 0) lines.push("Battery: " + node.batteryLevel + "%");
            return lines.join("\n");
        }

        function createMarkerIcon(node) {
            var color = getNodeColor(node);
            var shortName = node.shortName ? node.shortName.substring(0, 2) : "?";

            var html = '<div class="node-marker">' +
                '<div class="node-pin" style="background-color: ' + color + ';">' + shortName + '</div>' +
                '<div class="node-pointer" style="border-top-color: ' + color + ';"></div>' +
                '</div>';

            return L.divIcon({
                html: html,
                className: '',
                iconSize: [28, 36],
                iconAnchor: [14, 36],
                popupAnchor: [0, -36]
            });
        }

        // API functions called from C++
        window.mapAPI = {
            centerOn: function (lat, lon) {
                map.setView([lat, lon]);
            },

            setZoom: function (level) {
                map.setZoom(level);
            },

            updateNodes: function (nodes) {
                // Remove old markers
                for (var id in markers) {
                    map.removeLayer(markers[id]);
                }
                markers = {};

                // Collect bounds for auto-fit
                var bounds = [];

                // Add new markers
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.latitude === 0 && node.longitude === 0) continue;

                    var marker = L.marker([node.latitude, node.longitude], {
                        icon: createMarkerIcon(node)
                    });

                    marker.bindPopup('<div class="node-tooltip">' + buildTooltip(node) + '</div>');

                    // Store nodeNum for click handler
                    marker.nodeNum = node.nodeNum;
                    marker.on('click', function (e) {
                        if (window.mapBridge) {
                            mapBridge.notifyNodeClicked(e.target.nodeNum);
                        }
                    });

                    marker.addTo(map);
                    markers[node.nodeNum] = marker;
                    bounds.push([node.latitude, node.longitude]);
                }

                // Return bounds for C++ to use
                return bounds;
            },

            fitToNodes: function () {
                var markerIds = Object.keys(markers);
                if (markerIds.length === 0) return;

                var bounds = [];
                for (var i = 0; i < markerIds.length; i++) {
                    var m = markers[markerIds[i]];
                    bounds.push(m.getLatLng());
                }

                if (bounds.length === 1) {
                    map.setView(bounds[0], 14);
                } else if (bounds.length > 1) {
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                }
            },

            blinkNode: function (nodeNum, durationMs) {
                var marker = markers[nodeNum];
                if (!marker) return;

                var el = marker.getElement();
                if (!el) return;

                var markerDiv = el.querySelector('.node-marker');
                if (!markerDiv) return;

                // Add position relative for the ring pseudo-element
                markerDiv.style.position = 'relative';
                markerDiv.classList.add('node-blinking');

                setTimeout(function () {
                    markerDiv.classList.remove('node-blinking');
                }, durationMs || 10000);
            },

            selectNode: function (nodeNum) {
                var marker = markers[nodeNum];
                if (!marker) return;

                // Close any open popups
                map.closePopup();

                // Open this marker's popup
                marker.openPopup();

                // Brief highlight effect
                this.blinkNode(nodeNum, 2000);
            },

            setTileServer: function (url) {
                // Remove old tile layer
                if (currentTileLayer) {
                    map.removeLayer(currentTileLayer);
                }

                // Determine attribution based on URL
                var attribution = '&copy; OpenStreetMap contributors';
                if (url.indexOf('opentopomap') >= 0) {
                    attribution = '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>';
                } else if (url.indexOf('cartocdn') >= 0) {
                    attribution = '&copy; <a href="https://carto.com/">CARTO</a>';
                } else if (url.indexOf('stamen') >= 0) {
                    attribution = '&copy; <a href="https://stamen.com">Stamen Design</a>';
                }

                // Add new tile layer
                currentTileLayer = L.tileLayer(url, {
                    attribution: attribution,
                    maxZoom: 19
                }).addTo(map);
            },

            drawPacketFlow: function (fromNode, toNode, fromLat, fromLon, toLat, toLon) {
                // Create animated line from sender to receiver
                var latlngs = [[fromLat, fromLon], [toLat, toLon]];

                var line = L.polyline(latlngs, {
                    color: '#FFD700',
                    weight: 2,
                    opacity: 0.8,
                    dashArray: '5, 10',
                    className: 'packet-flow-line'
                }).addTo(map);

                // Store the line
                packetFlows.push(line);

                // Animate opacity fade out
                var opacity = 0.8;
                var fadeInterval = setInterval(function () {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        map.removeLayer(line);
                        // Remove from array
                        var idx = packetFlows.indexOf(line);
                        if (idx > -1) {
                            packetFlows.splice(idx, 1);
                        }
                    } else {
                        line.setStyle({ opacity: opacity });
                    }
                }, 100); // Fade over ~1.6 seconds

                // Limit number of lines
                if (packetFlows.length > maxFlowLines) {
                    var oldLine = packetFlows.shift();
                    map.removeLayer(oldLine);
                }
            },

            // Draw a traceroute path (persistent until cleared)
            // routePoints is an array of {lat, lon, name, snr} objects
            drawTraceroute: function (routePoints) {
                // Clear existing traceroute
                this.clearTraceroute();

                if (!routePoints || routePoints.length < 2) return;

                // Build path coordinates
                var latlngs = [];
                for (var i = 0; i < routePoints.length; i++) {
                    latlngs.push([routePoints[i].lat, routePoints[i].lon]);
                }

                // Draw the route line
                tracerouteLine = L.polyline(latlngs, {
                    color: '#00BFFF',  // Deep sky blue
                    weight: 4,
                    opacity: 0.9,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);

                // Add numbered markers for each hop
                for (var i = 0; i < routePoints.length; i++) {
                    var pt = routePoints[i];
                    var isEndpoint = (i === 0 || i === routePoints.length - 1);

                    var markerHtml = '<div style="' +
                        'background: ' + (isEndpoint ? '#00BFFF' : '#4A90D9') + ';' +
                        'color: white;' +
                        'border: 2px solid white;' +
                        'border-radius: 50%;' +
                        'width: ' + (isEndpoint ? '28px' : '22px') + ';' +
                        'height: ' + (isEndpoint ? '28px' : '22px') + ';' +
                        'display: flex;' +
                        'align-items: center;' +
                        'justify-content: center;' +
                        'font-weight: bold;' +
                        'font-size: ' + (isEndpoint ? '14px' : '11px') + ';' +
                        'box-shadow: 0 2px 6px rgba(0,0,0,0.4);' +
                        '">' + (i + 1) + '</div>';

                    var icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: isEndpoint ? [28, 28] : [22, 22],
                        iconAnchor: isEndpoint ? [14, 14] : [11, 11]
                    });

                    var tooltip = pt.name;
                    if (pt.snr !== undefined && pt.snr !== null) {
                        tooltip += '\nSNR: ' + pt.snr + ' dB';
                    }

                    var marker = L.marker([pt.lat, pt.lon], { icon: icon })
                        .bindTooltip(tooltip, { className: 'node-tooltip' })
                        .addTo(map);

                    tracerouteMarkers.push(marker);
                }

                // Fit map to show entire route
                map.fitBounds(latlngs, { padding: [50, 50], maxZoom: 14 });
            },

            clearTraceroute: function () {
                if (tracerouteLine) {
                    map.removeLayer(tracerouteLine);
                    tracerouteLine = null;
                }
                for (var i = 0; i < tracerouteMarkers.length; i++) {
                    map.removeLayer(tracerouteMarkers[i]);
                }
                tracerouteMarkers = [];
            },

            // Called when map is ready
            notifyReady: function () {
                if (window.mapBridge) {
                    mapBridge.notifyMapReady();
                }
            }
        };

        // DOMContentLoaded - map tiles are ready but QWebChannel might not be
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Map DOM ready');
        });
    </script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <script>
        // Set up Qt WebChannel
        window.mapBridge = null;

        function initWebChannel() {
            if (typeof QWebChannel === 'undefined') {
                console.log('QWebChannel not available, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            if (!window.qt || !window.qt.webChannelTransport) {
                console.log('WebChannel transport not ready, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            new QWebChannel(qt.webChannelTransport, function (channel) {
                window.mapBridge = channel.objects.mapBridge;
                console.log('WebChannel connected, mapBridge:', window.mapBridge);
                window.mapAPI.notifyReady();
            });
        }

        // Start initialization after a brief delay
        setTimeout(initWebChannel, 50);
    </script>
</body>

</html>