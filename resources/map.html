<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            width: 100%;
            height: 100%;
            background: #1a1a2e;
        }

        .node-marker {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .node-pin {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2.5px solid rgba(255,255,255,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 0 1px rgba(0,0,0,0.1);
        }

        .node-pin.my-node {
            border: 3px solid #ffffff;
            box-shadow: 0 2px 8px rgba(66,133,244,0.6), 0 0 12px rgba(66,133,244,0.3);
        }

        .node-pin.low-battery {
            box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 0 3px rgba(244,67,54,0.5);
        }

        .node-pointer {
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 9px solid rgba(255,255,255,0.85);
            margin-top: -2px;
        }

        .node-pointer.my-node {
            border-top-color: #ffffff;
        }

        .node-label {
            margin-top: 2px;
            font-size: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            color: #333;
            text-shadow: 0 0 3px white, 0 0 3px white, 0 0 3px white;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }

        /* Rich popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 10px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            padding: 0;
        }

        .leaflet-popup-content {
            margin: 0;
            min-width: 200px;
        }

        .node-popup {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.4;
        }

        .node-popup-header {
            padding: 10px 14px 8px;
            border-bottom: 1px solid #eee;
        }

        .node-popup-name {
            font-size: 15px;
            font-weight: 700;
            color: #212529;
            margin: 0;
        }

        .node-popup-subname {
            font-size: 11px;
            color: #6c757d;
            margin-top: 2px;
        }

        .node-popup-body {
            padding: 8px 14px 10px;
        }

        .node-popup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
        }

        .node-popup-label {
            color: #6c757d;
            font-size: 12px;
        }

        .node-popup-value {
            font-weight: 600;
            color: #212529;
            font-size: 12px;
        }

        .battery-bar {
            display: inline-block;
            width: 40px;
            height: 10px;
            border: 1px solid #aaa;
            border-radius: 2px;
            overflow: hidden;
            vertical-align: middle;
            margin-left: 4px;
        }

        .battery-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }

        /* Attribution styling */
        .leaflet-control-attribution {
            background: rgba(255,255,255,0.6) !important;
            font-size: 10px !important;
            padding: 2px 6px !important;
        }

        @keyframes node-blink {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7);
            }

            50% {
                transform: scale(1.2);
                box-shadow: 0 0 20px 10px rgba(255, 255, 0, 0.9);
            }
        }

        @keyframes node-ring {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .node-blinking .node-pin {
            animation: node-blink 0.8s ease-in-out infinite;
            z-index: 1000 !important;
        }

        .node-blinking::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            margin-top: -15px;
            margin-left: -15px;
            border: 3px solid #ffff00;
            border-radius: 50%;
            animation: node-ring 1.2s ease-out infinite;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>
        // Role name mapping
        var roleNames = {
            0: 'Client', 1: 'Client Mute', 2: 'Router', 3: 'Router Client',
            4: 'Repeater', 5: 'Tracker', 6: 'Sensor', 7: 'TAK',
            8: 'Client Hidden', 9: 'Lost & Found', 10: 'TAK Tracker'
        };

        // Initialize map
        var map = L.map('map', {
            zoomControl: true
        }).setView([37.7749, -122.4194], 10);

        // Add scale control
        L.control.scale({ imperial: true, metric: true }).addTo(map);

        // Add tile layer (default OpenStreetMap)
        var currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
            maxZoom: 19
        }).addTo(map);

        // Store markers
        var markers = {};

        // Store packet flow lines
        var packetFlows = [];
        var maxFlowLines = 100;

        // Store traceroute line
        var tracerouteLine = null;
        var tracerouteMarkers = [];

        function getNodeColor(node) {
            if (node.isMyNode) return '#4285f4'; // bright blue for my node
            if (node.lastHeardSecs >= 0 && node.lastHeardSecs < 900) {
                // Online (< 15 min) - green tones
                return '#34a853';
            }
            if (node.lastHeardSecs >= 900) {
                // Stale - muted gray
                return '#9e9e9e';
            }
            // Fallback based on battery
            if (node.batteryLevel > 0) {
                if (node.batteryLevel < 20) return '#ea4335';
                if (node.batteryLevel < 50) return '#fbbc04';
                return '#34a853';
            }
            return '#5f6368';
        }

        function formatRelativeTime(secs) {
            if (secs < 0) return 'Unknown';
            if (secs < 60) return secs + 's ago';
            if (secs < 3600) return Math.floor(secs / 60) + ' min ago';
            if (secs < 86400) return Math.floor(secs / 3600) + 'h ago';
            return Math.floor(secs / 86400) + 'd ago';
        }

        function getBatteryColor(level) {
            if (level > 60) return '#34a853';
            if (level > 30) return '#fbbc04';
            return '#ea4335';
        }

        function buildPopup(node) {
            var name = node.longName || node.nodeId || 'Unknown';
            var sub = [];
            if (node.shortName) sub.push(node.shortName);
            if (node.nodeId) sub.push(node.nodeId);

            var html = '<div class="node-popup">';
            html += '<div class="node-popup-header">';
            html += '<div class="node-popup-name">' + name + '</div>';
            if (sub.length > 0) {
                html += '<div class="node-popup-subname">' + sub.join(' &middot; ') + '</div>';
            }
            html += '</div>';
            html += '<div class="node-popup-body">';

            // Battery
            if (node.batteryLevel > 0) {
                var batColor = getBatteryColor(node.batteryLevel);
                var batText = node.isExternalPower ? 'Plugged' : node.batteryLevel + '%';
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Battery</span>';
                html += '<span class="node-popup-value">' + batText;
                html += ' <span class="battery-bar"><span class="battery-bar-fill" style="width:' + node.batteryLevel + '%;background:' + batColor + '"></span></span>';
                html += '</span></div>';
            }

            // Signal
            if (node.hopsAway === 0 && (node.snr !== 0 || node.rssi !== 0)) {
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Signal</span>';
                html += '<span class="node-popup-value">SNR ' + node.snr.toFixed(1) + ' dB / RSSI ' + node.rssi + '</span>';
                html += '</div>';
            } else if (node.hopsAway > 0) {
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Hops</span>';
                html += '<span class="node-popup-value">' + node.hopsAway + ' hop' + (node.hopsAway > 1 ? 's' : '') + '</span>';
                html += '</div>';
            }

            // Last heard
            if (node.lastHeardSecs >= 0) {
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Last heard</span>';
                html += '<span class="node-popup-value">' + formatRelativeTime(node.lastHeardSecs) + '</span>';
                html += '</div>';
            }

            // Altitude
            if (node.altitude && node.altitude !== 0) {
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Altitude</span>';
                html += '<span class="node-popup-value">' + node.altitude + ' m</span>';
                html += '</div>';
            }

            // Role
            if (node.role !== undefined && node.role > 0) {
                var roleName = roleNames[node.role] || ('Role ' + node.role);
                html += '<div class="node-popup-row">';
                html += '<span class="node-popup-label">Role</span>';
                html += '<span class="node-popup-value">' + roleName + '</span>';
                html += '</div>';
            }

            html += '</div></div>';
            return html;
        }

        function createMarkerIcon(node) {
            var color = getNodeColor(node);
            var shortName = node.shortName ? node.shortName.substring(0, 3) : '?';
            var isMyNode = node.isMyNode;
            var isLowBat = (node.batteryLevel > 0 && node.batteryLevel < 20 && !node.isExternalPower);
            var displayName = node.longName || node.shortName || '';

            var pinClasses = 'node-pin';
            if (isMyNode) pinClasses += ' my-node';
            if (isLowBat) pinClasses += ' low-battery';

            var pointerClass = 'node-pointer' + (isMyNode ? ' my-node' : '');

            var html = '<div class="node-marker">' +
                '<div class="' + pinClasses + '" style="background-color: ' + color + ';">' + shortName + '</div>' +
                '<div class="' + pointerClass + '" style="border-top-color: ' + (isMyNode ? '#ffffff' : 'rgba(255,255,255,0.85)') + ';"></div>';

            // Add name label
            if (displayName) {
                html += '<div class="node-label">' + displayName + '</div>';
            }

            html += '</div>';

            return L.divIcon({
                html: html,
                className: '',
                iconSize: [30, 52],
                iconAnchor: [15, 42],
                popupAnchor: [0, -42]
            });
        }

        // API functions called from C++
        window.mapAPI = {
            centerOn: function (lat, lon) {
                map.setView([lat, lon]);
            },

            setZoom: function (level) {
                map.setZoom(level);
            },

            updateNodes: function (nodes) {
                // Remove old markers
                for (var id in markers) {
                    map.removeLayer(markers[id]);
                }
                markers = {};

                // Collect bounds for auto-fit
                var bounds = [];

                // Add new markers
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.latitude === 0 && node.longitude === 0) continue;

                    var marker = L.marker([node.latitude, node.longitude], {
                        icon: createMarkerIcon(node),
                        zIndexOffset: node.isMyNode ? 1000 : 0
                    });

                    marker.bindPopup(buildPopup(node), {
                        maxWidth: 280,
                        className: ''
                    });

                    // Store nodeNum for click handler
                    marker.nodeNum = node.nodeNum;
                    marker.on('click', function (e) {
                        if (window.mapBridge) {
                            mapBridge.notifyNodeClicked(e.target.nodeNum);
                        }
                    });

                    marker.addTo(map);
                    markers[node.nodeNum] = marker;
                    bounds.push([node.latitude, node.longitude]);
                }

                // Return bounds for C++ to use
                return bounds;
            },

            fitToNodes: function () {
                var markerIds = Object.keys(markers);
                if (markerIds.length === 0) return;

                var bounds = [];
                for (var i = 0; i < markerIds.length; i++) {
                    var m = markers[markerIds[i]];
                    bounds.push(m.getLatLng());
                }

                if (bounds.length === 1) {
                    map.setView(bounds[0], 14);
                } else if (bounds.length > 1) {
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                }
            },

            blinkNode: function (nodeNum, durationMs) {
                var marker = markers[nodeNum];
                if (!marker) return;

                var el = marker.getElement();
                if (!el) return;

                var markerDiv = el.querySelector('.node-marker');
                if (!markerDiv) return;

                // Add position relative for the ring pseudo-element
                markerDiv.style.position = 'relative';
                markerDiv.classList.add('node-blinking');

                setTimeout(function () {
                    markerDiv.classList.remove('node-blinking');
                }, durationMs || 10000);
            },

            selectNode: function (nodeNum) {
                var marker = markers[nodeNum];
                if (!marker) return;

                // Close any open popups
                map.closePopup();

                // Open this marker's popup
                marker.openPopup();

                // Brief highlight effect
                this.blinkNode(nodeNum, 2000);
            },

            setTileServer: function (url) {
                // Remove old tile layer
                if (currentTileLayer) {
                    map.removeLayer(currentTileLayer);
                }

                // Determine attribution based on URL
                var attribution = '&copy; OpenStreetMap contributors';
                if (url.indexOf('opentopomap') >= 0) {
                    attribution = '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>';
                } else if (url.indexOf('cartocdn') >= 0) {
                    attribution = '&copy; <a href="https://carto.com/">CARTO</a>';
                } else if (url.indexOf('stamen') >= 0) {
                    attribution = '&copy; <a href="https://stamen.com">Stamen Design</a>';
                }

                // Add new tile layer
                currentTileLayer = L.tileLayer(url, {
                    attribution: attribution,
                    maxZoom: 19
                }).addTo(map);
            },

            drawPacketFlow: function (fromNode, toNode, fromLat, fromLon, toLat, toLon) {
                // Create animated line from sender to receiver
                var latlngs = [[fromLat, fromLon], [toLat, toLon]];

                var line = L.polyline(latlngs, {
                    color: '#FFD700',
                    weight: 2,
                    opacity: 0.8,
                    dashArray: '5, 10',
                    className: 'packet-flow-line'
                }).addTo(map);

                // Store the line
                packetFlows.push(line);

                // Animate opacity fade out
                var opacity = 0.8;
                var fadeInterval = setInterval(function () {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        map.removeLayer(line);
                        // Remove from array
                        var idx = packetFlows.indexOf(line);
                        if (idx > -1) {
                            packetFlows.splice(idx, 1);
                        }
                    } else {
                        line.setStyle({ opacity: opacity });
                    }
                }, 100); // Fade over ~1.6 seconds

                // Limit number of lines
                if (packetFlows.length > maxFlowLines) {
                    var oldLine = packetFlows.shift();
                    map.removeLayer(oldLine);
                }
            },

            // Draw a traceroute path (persistent until cleared)
            // routePoints is an array of {lat, lon, name, snr} objects
            drawTraceroute: function (routePoints) {
                // Clear existing traceroute
                this.clearTraceroute();

                if (!routePoints || routePoints.length < 2) return;

                // Build path coordinates
                var latlngs = [];
                for (var i = 0; i < routePoints.length; i++) {
                    latlngs.push([routePoints[i].lat, routePoints[i].lon]);
                }

                // Draw the route line
                tracerouteLine = L.polyline(latlngs, {
                    color: '#00BFFF',  // Deep sky blue
                    weight: 4,
                    opacity: 0.9,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);

                // Add numbered markers for each hop
                for (var i = 0; i < routePoints.length; i++) {
                    var pt = routePoints[i];
                    var isEndpoint = (i === 0 || i === routePoints.length - 1);

                    var markerHtml = '<div style="' +
                        'background: ' + (isEndpoint ? '#00BFFF' : '#4A90D9') + ';' +
                        'color: white;' +
                        'border: 2px solid white;' +
                        'border-radius: 50%;' +
                        'width: ' + (isEndpoint ? '28px' : '22px') + ';' +
                        'height: ' + (isEndpoint ? '28px' : '22px') + ';' +
                        'display: flex;' +
                        'align-items: center;' +
                        'justify-content: center;' +
                        'font-weight: bold;' +
                        'font-size: ' + (isEndpoint ? '14px' : '11px') + ';' +
                        'box-shadow: 0 2px 6px rgba(0,0,0,0.4);' +
                        '">' + (i + 1) + '</div>';

                    var icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: isEndpoint ? [28, 28] : [22, 22],
                        iconAnchor: isEndpoint ? [14, 14] : [11, 11]
                    });

                    var tooltip = pt.name;
                    if (pt.snr !== undefined && pt.snr !== null) {
                        tooltip += '\nSNR: ' + pt.snr + ' dB';
                    }

                    var marker = L.marker([pt.lat, pt.lon], { icon: icon })
                        .bindTooltip(tooltip, { className: 'node-tooltip' })
                        .addTo(map);

                    tracerouteMarkers.push(marker);
                }

                // Fit map to show entire route
                map.fitBounds(latlngs, { padding: [50, 50], maxZoom: 14 });
            },

            clearTraceroute: function () {
                if (tracerouteLine) {
                    map.removeLayer(tracerouteLine);
                    tracerouteLine = null;
                }
                for (var i = 0; i < tracerouteMarkers.length; i++) {
                    map.removeLayer(tracerouteMarkers[i]);
                }
                tracerouteMarkers = [];
            },

            // Called when map is ready
            notifyReady: function () {
                if (window.mapBridge) {
                    mapBridge.notifyMapReady();
                }
            }
        };

        // DOMContentLoaded - map tiles are ready but QWebChannel might not be
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Map DOM ready');
        });
    </script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <script>
        // Set up Qt WebChannel
        window.mapBridge = null;

        function initWebChannel() {
            if (typeof QWebChannel === 'undefined') {
                console.log('QWebChannel not available, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            if (!window.qt || !window.qt.webChannelTransport) {
                console.log('WebChannel transport not ready, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            new QWebChannel(qt.webChannelTransport, function (channel) {
                window.mapBridge = channel.objects.mapBridge;
                console.log('WebChannel connected, mapBridge:', window.mapBridge);
                window.mapAPI.notifyReady();
            });
        }

        // Start initialization after a brief delay
        setTimeout(initWebChannel, 50);
    </script>
</body>

</html>
