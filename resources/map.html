<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; }
        html, body, #map { width: 100%; height: 100%; }
        .node-marker {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .node-pin {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            font-family: Arial, sans-serif;
        }
        .node-pointer {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #333;
            margin-top: -2px;
        }
        .node-tooltip {
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: Arial, sans-serif;
            white-space: pre-line;
        }
        @keyframes node-blink {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7); }
            50% { transform: scale(1.2); box-shadow: 0 0 20px 10px rgba(255, 255, 0, 0.9); }
        }
        @keyframes node-ring {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        .node-blinking .node-pin {
            animation: node-blink 0.8s ease-in-out infinite;
            z-index: 1000 !important;
        }
        .node-blinking::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            margin-top: -12px;
            margin-left: -12px;
            border: 3px solid #ffff00;
            border-radius: 50%;
            animation: node-ring 1.2s ease-out infinite;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        // Initialize map
        var map = L.map('map', {
            zoomControl: true
        }).setView([37.7749, -122.4194], 10);

        // Add tile layer (default OpenStreetMap)
        var currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
            maxZoom: 19
        }).addTo(map);

        // Store markers
        var markers = {};

        // Color palette for nodes
        var colors = ["#4A90D9", "#D94A4A", "#4AD94A", "#D9D94A", "#D94AD9", "#4AD9D9"];

        function getNodeColor(node) {
            if (node.batteryLevel > 0) {
                if (node.batteryLevel < 20) return "#FF4444";
                if (node.batteryLevel < 50) return "#FFAA00";
                return "#44AA44";
            }
            return colors[node.nodeNum % colors.length];
        }

        function buildTooltip(node) {
            var lines = [];
            if (node.longName) lines.push(node.longName);
            if (node.nodeId) lines.push(node.nodeId);
            if (node.altitude) lines.push("Alt: " + node.altitude + "m");
            if (node.batteryLevel > 0) lines.push("Battery: " + node.batteryLevel + "%");
            return lines.join("\n");
        }

        function createMarkerIcon(node) {
            var color = getNodeColor(node);
            var shortName = node.shortName ? node.shortName.substring(0, 2) : "?";

            var html = '<div class="node-marker">' +
                '<div class="node-pin" style="background-color: ' + color + ';">' + shortName + '</div>' +
                '<div class="node-pointer" style="border-top-color: ' + color + ';"></div>' +
                '</div>';

            return L.divIcon({
                html: html,
                className: '',
                iconSize: [28, 36],
                iconAnchor: [14, 36],
                popupAnchor: [0, -36]
            });
        }

        // API functions called from C++
        window.mapAPI = {
            centerOn: function(lat, lon) {
                map.setView([lat, lon]);
            },

            setZoom: function(level) {
                map.setZoom(level);
            },

            updateNodes: function(nodes) {
                // Remove old markers
                for (var id in markers) {
                    map.removeLayer(markers[id]);
                }
                markers = {};

                // Collect bounds for auto-fit
                var bounds = [];

                // Add new markers
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.latitude === 0 && node.longitude === 0) continue;

                    var marker = L.marker([node.latitude, node.longitude], {
                        icon: createMarkerIcon(node)
                    });

                    marker.bindPopup('<div class="node-tooltip">' + buildTooltip(node) + '</div>');

                    // Store nodeNum for click handler
                    marker.nodeNum = node.nodeNum;
                    marker.on('click', function(e) {
                        if (window.mapBridge) {
                            mapBridge.notifyNodeClicked(e.target.nodeNum);
                        }
                    });

                    marker.addTo(map);
                    markers[node.nodeNum] = marker;
                    bounds.push([node.latitude, node.longitude]);
                }

                // Return bounds for C++ to use
                return bounds;
            },

            fitToNodes: function() {
                var markerIds = Object.keys(markers);
                if (markerIds.length === 0) return;

                var bounds = [];
                for (var i = 0; i < markerIds.length; i++) {
                    var m = markers[markerIds[i]];
                    bounds.push(m.getLatLng());
                }

                if (bounds.length === 1) {
                    map.setView(bounds[0], 14);
                } else if (bounds.length > 1) {
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                }
            },

            blinkNode: function(nodeNum, durationMs) {
                var marker = markers[nodeNum];
                if (!marker) return;

                var el = marker.getElement();
                if (!el) return;

                var markerDiv = el.querySelector('.node-marker');
                if (!markerDiv) return;

                // Add position relative for the ring pseudo-element
                markerDiv.style.position = 'relative';
                markerDiv.classList.add('node-blinking');

                setTimeout(function() {
                    markerDiv.classList.remove('node-blinking');
                }, durationMs || 10000);
            },

            selectNode: function(nodeNum) {
                var marker = markers[nodeNum];
                if (!marker) return;

                // Close any open popups
                map.closePopup();

                // Open this marker's popup
                marker.openPopup();

                // Brief highlight effect
                this.blinkNode(nodeNum, 2000);
            },

            setTileServer: function(url) {
                // Remove old tile layer
                if (currentTileLayer) {
                    map.removeLayer(currentTileLayer);
                }

                // Determine attribution based on URL
                var attribution = '&copy; OpenStreetMap contributors';
                if (url.indexOf('opentopomap') >= 0) {
                    attribution = '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>';
                } else if (url.indexOf('cartocdn') >= 0) {
                    attribution = '&copy; <a href="https://carto.com/">CARTO</a>';
                } else if (url.indexOf('stamen') >= 0) {
                    attribution = '&copy; <a href="https://stamen.com">Stamen Design</a>';
                }

                // Add new tile layer
                currentTileLayer = L.tileLayer(url, {
                    attribution: attribution,
                    maxZoom: 19
                }).addTo(map);
            },

            // Called when map is ready
            notifyReady: function() {
                if (window.mapBridge) {
                    mapBridge.notifyMapReady();
                }
            }
        };

        // DOMContentLoaded - map tiles are ready but QWebChannel might not be
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Map DOM ready');
        });
    </script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <script>
        // Set up Qt WebChannel
        window.mapBridge = null;

        function initWebChannel() {
            if (typeof QWebChannel === 'undefined') {
                console.log('QWebChannel not available, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            if (!window.qt || !window.qt.webChannelTransport) {
                console.log('WebChannel transport not ready, retrying...');
                setTimeout(initWebChannel, 100);
                return;
            }

            new QWebChannel(qt.webChannelTransport, function(channel) {
                window.mapBridge = channel.objects.mapBridge;
                console.log('WebChannel connected, mapBridge:', window.mapBridge);
                window.mapAPI.notifyReady();
            });
        }

        // Start initialization after a brief delay
        setTimeout(initWebChannel, 50);
    </script>
</body>
</html>
